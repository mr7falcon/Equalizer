Минимизация задержек

1. Увеличение размера буфера.
Самый очевидный и простой вариант. Увеличив размер буфера до внушительных размеров, щелчки будут проскальзывать редко, но они будут 
довольно ощутимы, однако, возможно, звучание будет приемлимым. Не сложно догадаться, что это очень неэкономичный вариант.

Размер буфера				 Оценка задержек
16кб						 Задержки полностью искажают звучание
128кб						 Щелчки сильно заметны. Частота около пяти раз в секунду
512кб						 Щелчки сильнозаметны. Частота около раза в три секунды

2. Увеличение количества буферов
Если создать дополнительный буфер, в который во время проигрывания первого в параллельном потоке копировать данные из файла, то можно минимизировать
задержки на загрузку данных. После того, как закончится проигрывание одного буфера, второй (уже заполненный) тут же подменяет его.

Размер буфера				 Оценка задержек
16кб						 Задержки полностью искажают звучание
128кб						 Щелчки слабо заметны. Частота около пяти раз в секунду
512кб						 Щелчки слабо заметны. Частота около раза в три секунды

3. Разделение основного буфера на секции
В предыдущем примере по идее задержек копирования уже быть не должно, ведь все происходит параллельно. Однако, это не так. Дело в том, что программных
буферов можно создавать сколько угодно, а аппаратный буфер всего один (им заведует драйвер звуковой карты). Таким образом, подменяя один буфер на другой,
все равно происходит полное копирование новых данных в аппаратный буфер. Не смотря на то, что исключаются задержки чтения и передачи данных, щелчки никуда
не денутся, хоть и станут менее заметны. Решение следующее. Пусть один буфер будет основным, а второй дополнительным. Проигрывается только основной буфер.
Интерфейс DirectSound позволяет запросить уведомления по прохождении определенных позиций чтения (проигрывания) в основном буфере. Разделяем его на n
секций размером bufferSize / n, запрашиваем уведомление на прохождение границы каждой из них. Второй буфер будет равен размеру одной секции. В нем будут
заранее находиться очередные данные. Таким образом, при получении события о прохождении i-той секции берем данные из дополнительного буфера и копируем их
в эту секцию, после чего в параллельном потоке обновляем дополнительный его. Получается, что как только какая-то область буфера будет проиграна, на ее
место тут же начинают копироваться новые данные, пока идет проигрывание остальных областей.

Размер основного буфера				Размер дополнительного буфера				Количество секций				 Оценка задержек
16384б								8192										2								 Нет		
8192б								4096										2								 Задержки полностью искажают звучание

8192б								2048										4		 						 Нет
4096б								1024										4								 Задержки полностью искажают звучание

8192б								1024										8								 Задержки полностью искажают звучание

Как видно из таблицы выше, нет смысла делить буфер больше, чем на 4 секции, так как данные проигрываются быстрее, чем успевают обрабатываться.

Таким образом, удалось ПОЛНОСТЬЮ УБРАТЬ задержки, при этом сократив память под буферы до 10кб!

Целью следующего этапа разработки становится добавление фильтров, при этом сохраняя качественное звучание.
По результатам сборки эквалайзера приходится существенно увеличить объем буфера по прочине добавления большого количества параллельной логики (фильтров).
- самплы не успевают обрабатываться во время проигрывания. В моем случае (10 полос) объем буфера был увеличен до 64кб. Так мы
обеспечиваем стабильную работу программы.

КИХ:
При добавлении фильтров могут возникнуть регулярные щелчки, сильно искажающие звучание. Их причина - свертка: чтобы рассчитать i-ый отсчет выхода
фильтра необходимо знать Р предыдущих отсчетов входа, где Р - порядок фильтра. Но, так как данные передаются кусками, получается, что рассчитать первые
Р отсчетов выхода в каждом куске не представляется возможным (индексы массива входа уходят в минус). Поэтому и возникают щелчки в начале каждого сампла.
Не сложно догадаться, что для решения этой проблемы необходимо запоминать последние Р отсчетов предыдущего куска, проходящего через фильтр. Таким
образом мы обеспечим "непрерывность" данных на выходе фильтра и избавимся от щелчков.

Объем буфера				Процессор
64кб						60%

БИХ:
Есть несколько форм построения БИХ фильтра. В нашем случае используется каскадное соединение секций Direct Form II 2-го порядка. Благодаря этому
во избежание щелчков нам необходимо хранить только два последних выходных отсчета фильтра.

Объем буфера 				Процессор
64кб						5%

Гораздо меньшая по сравнению с КИХ фильтром загрузка процессора легко объяснима: там как порядок любого КИХ фильтра гораздо выше порядка БИХ фильтра,
количество вычислений в каждом потоке фильтра у него больше. На моем примере: порядок КИХ фильтра - 500, БИХ фильтра - 30. Таким образом количество итераций
КИХ фильтра за один сампл (объем сампла 16кб) = 16384 * 501 = 8208384, в то время как у БИХ фильтра: 16384 * 15 (кол-во секций при порядке 30) = 245760.

Эффекты.
При реализации эффекта Delay также необходимо хранить Т предыдущих отсчетов (где Т - количество отсчетов задержки) для избежания щелчков при
воспроизведении с применением эффекта.